метод find()
Если метод  filter(callback) используется для поиска всех удовлетворяющих условий элементов, то метод  find(callback) позволяет найти и вернуть первый подходящий элемент, после чего переборка массива прекращается.То есть он ищет до первого совпадения

arr. find ( ( element, index, array ) => {
   // Тело колбек-функции
});

//================

Не изменяет оригинальный массив.
Поэлемент перебирает оригинальный массив.
Возвращает первый удовлетворяющий условие элемент, то есть когда колбек возвращает  true.
Если ни один элемент не удовлетворил условие, то есть для всех элементов колбек вернул  false, метод возвращает  undefined.


Метод  find() используется для одной задачи – поиска элемента по уникальному значению свойства.Например, поиск пользователя по почте, автомобиля – по серийному номеру, книги – по названию и т.д.

const colorPickerOptions = [
  { label: "red", color: "#F44336" },
  { label: "green", color: "#4CAF50" },
  { label: "blue", color: "#2196F3" },
  { label: "pink", color: "#E91E63" },
  { label: "indigo", color: "#3F51B5" },
];

colorPickerOptions.find(option => option.label === "blue"); // { label: 'blue', color: '#2196F3' }
colorPickerOptions.find(option => option.label === "pink"); // { label: 'pink', color: '#E91E63' }
colorPickerOptions.find(option => option.label === "white"); // undefined

//=================================

метод findIndex()
Метод  findIndex(callback) – это современная замена метода  indexOf().Позволяет выполнять поиск по более сложным условиям, чем просто равенство.Используется как для поиска в массиве примитивов, так и в массиве объектов.

arr.findIndex((element, index, array) => {
  // Тіло колбек-функції
});

Не изменяет оригинальный массив.
Поэлемент перебирает оригинальный массив.
Возвращает индекс первого элемента, удовлетворяющего условию, то есть когда колбек возвращает  true.
Если ни один элемент не удовлетворяет условию, то есть для всех элементов колбек вернул  false, метод возвращает - 1.

const colorPickerOptions = [
  { label: "red", color: "#F44336" },
  { label: "green", color: "#4CAF50" },
  { label: "blue", color: "#2196F3" },
  { label: "pink", color: "#E91E63" },
  { label: "indigo", color: "#3F51B5" },
];

colorPickerOptions.findIndex(option => option.label === "blue"); // 2
colorPickerOptions.findIndex(option => option.label === "pink"); // 3
colorPickerOptions.findIndex(option => option.label === "white"); // -1

//===========================

Методы every() и some()
Метод every()

Проверяет, проходят ли все элементы массива тест колбек - функции.Возвращает  true или  false.

arr.every((element, index, array) => {
  // Тіло колбек-функції
});

Не изменяет оригинальный массив.
Поэлемент перебирает оригинальный массив.
Возвращает  true, если все элементы массива удовлетворяют условию.
Возвращает  false, если хотя бы один элемент массива не удовлетворяет условию.
Переборка массива прекращается, если колбек возвращает  false.

// Усі елементи більші або дорівнюють нулю? - так
[1, 2, 3, 4, 5].every(value => value >= 0); // true

// Усі елементи більші або дорівнюють нулю? - ні
[1, 2, 3, -10, 4, 5].every(value => value >= 0); // false


Метод some()

Проверяет, проходит ли хотя бы один элемент массива тест колбек - функции.Возвращает  true или  false.

arr.some((element, index, array) => {
  // Тіло колбек-функції
});

Не изменяет оригинальный массив.
Поэлемент перебирает оригинальный массив.
Возвращает  true, если хотя бы один элемент массива удовлетворяет условию.
Возвращает  false, если ни один элемент массива не удовлетворяет условию.
Переборка массива прекращается, если колбек возвращает  true.

// Чи є хоча б один елемент, що більший або дорівнює нулю? - так
[1, 2, 3, 4, 5].some(value => value >= 0); // true

// Чи є хоча б один елемент, що більший або дорівнює нулю? - так
[-7, -20, 3, -10, -14].some(value => value >= 0); // true

// Чи є хоча б один елемент, що менший нуля? - ні
[1, 2, 3, 4, 5].some(value => value < 0); // false

// Чи є хоча б один елемент, що менший нуля? - так
[1, 2, 3, -10, 4, 5].some(value => value < 0); // true


Массив объектов

При работе с массивом объектов проверяется значение определенного свойства.Например, у нас есть массив объектов фруктов, необходимо узнать, есть ли фрукты в наличии и есть ли в наличии хотя бы какие - нибудь фрукты, то есть более 0 штук.

const fruits = [
  { name: "apples", amount: 100 },
  { name: "bananas", amount: 0 },
  { name: "grapes", amount: 50 },
];

// every поверне true тільки, якщо усіх фруктів буде більше 0 штук
const allAvailable = fruits.every(fruit => fruit.amount > 0); // false

// some поверне true, якщо хоча б одного фрукту буде більше 0 штук
const anyAvailable = fruits.some(fruits => fruits.amount > 0); // true

//=========================

Метод reduce()
Метод  reduce(callback, initialValue) используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата как аккумулятор.Несколько сложнее других методов для усвоения, но результат того стоит.

arr.reduce((previousValue, element, index, array) => {
  // Тіло колбек-функції
}, initialValue);


Не изменяет оригинальный массив.
Поэлемент перебирает оригинальный массив.
Возвращает все, что угодно.
Делает все что угодно.
Легче всего представить его работу на примере подсчета суммы элементов массива.

const total = [2, 7, 3, 14, 6].reduce((previousValue, number) => {
  return previousValue + number;
}, 0);

console.log(total); // 32


Первый параметр колбек-функции ( previousValue) – это аккумулятор, то есть промежуточный результат. Значение, которое вернет колбек-функция на текущей итерации, будет являться значением этого параметра на следующей итерации.

Вторым аргументом  reduce() можно передать необязательное начальное значение аккумулятора - параметр  initialValue.

# Спочатку метод reduce() створює внутрішню змінну-акумулятор і
# присвоює їй значення параметра initialValue або першого елемента
# масиву, що перебирається, якщо initialValue не задане.
previousValue = 0

# Потім колбек-функція викликається для кожного елемента масиву. Поточне значення
# параметра previousValue - це те, що повернула колбек-функція на минулій ітерації.
Ітерація 1 -> previousValue = 0 -> number = 2 -> return 0 + 2 -> return 2
Ітерація 2 -> previousValue = 2 -> number = 7 -> return 2 + 7 -> return 9
Ітерація 3 -> previousValue = 9 -> number = 3 -> return 9 + 3 -> return 12
Ітерація 4 -> previousValue = 12 -> number = 14 -> return 12 + 14 -> return 26
Ітерація 5 -> previousValue = 26 -> number = 6 -> return 26 + 6 -> return 32

# Після завершення перебирання всього масиву, метод reduce() повертає значення акумулятора.
Результат - 32


То есть метод  reduce() используется, когда необходимо взять «многое» и привести к «одному». В повседневных задачах его применение сводится к работе с числами.



Массив объектов

При работе с массивом объектов выполняется редуцирование по определенному свойству.К примеру, у нас есть массив студентов с баллами за тест.Необходимо получить средний балл.


const students = [
  { name: "Манго", score: 83 },
  { name: "Полі", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Ківі", score: 94 },
  { name: "Х'юстон", score: 64 },
];

// Назва акумулятора може бути довільною, це просто параметр функції
const totalScore = students.reduce((total, student) => {
  return total + student.score;
}, 0);

const averageScore = totalScore / students.length;

Продвинутый reduce

Допустим, у нас есть следующая задача: из массива постов твиттера отдельного пользователя необходимо посчитать сумму всех лайков.Можно выбрать цикл  for или  forEach, каждое из этих решений потребует написания дополнительного кода.А можно использовать  reduce.

const tweets = [
  { id: "000", likes: 5, tags: ["js", "nodejs"] },
  { id: "001", likes: 2, tags: ["html", "css"] },
  { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
  { id: "003", likes: 8, tags: ["css", "react"] },
  { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
];

// Пройдемо по всіх елементах колекції і додамо значення властивості likes
// до акумулятора, початкове значення якого вкажемо 0.
const likes = tweets.reduce((totalLikes, tweet) => totalLikes + tweet.likes, 0);

console.log(likes); // 32

// Мабуть, підрахунок лайків - не одиночна операція, тому напишемо функцію
// для підрахунку лайків з колекції
const countLikes = tweets => {
  return tweets.reduce((totalLikes, tweet) => totalLikes + tweet.likes, 0);
};

console.log(countLikes(tweets)); // 32



Заметили ли свойство  tags у каждого поста ? Продолжая тему  reduce, мы соберем в массив все теги, встречающиеся в постах.

const tweets = [
  { id: "000", likes: 5, tags: ["js", "nodejs"] },
  { id: "001", likes: 2, tags: ["html", "css"] },
  { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
  { id: "003", likes: 8, tags: ["css", "react"] },
  { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
];

// Пройдемо по всіх елементах колекції і додамо значення властивості tags
// до акумулятора, початкове значення якого вкажемо порожнім масивом [].
// На кожній ітерації пушимо в акумулятор усі елементи tweet.tags і повертаємо його.
const tags = tweets.reduce((allTags, tweet) => {
  allTags.push(...tweet.tags);

  return allTags;
}, []);

console.log(tags);

// Мабуть, збирання тегів - не одиночна операція, тому напишемо функцію
// для збирання тегів з колекції
const getTags = tweets =>
  tweets.reduce((allTags, tweet) => {
    allTags.push(...tweet.tags);

    return allTags;
  }, []);

console.log(getTags(tweets));


После того, как мы собрали все тэги с постов, хорошо бы посчитать количество уникальных тегов в массиве.И снова  reduce пригодится.

const tweets = [
  { id: "000", likes: 5, tags: ["js", "nodejs"] },
  { id: "001", likes: 2, tags: ["html", "css"] },
  { id: "002", likes: 17, tags: ["html", "js", "nodejs"] },
  { id: "003", likes: 8, tags: ["css", "react"] },
  { id: "004", likes: 0, tags: ["js", "nodejs", "react"] },
];

const getTags = tweets =>
  tweets.reduce((allTags, tweet) => {
    allTags.push(...tweet.tags);

    return allTags;
  }, []);

const tags = getTags(tweets);

// Винесемо callback-функцію окремо, а в reducе передамо посилання на неї.
// Це стандартна практика, якщо callback-функція досить велика.

// Якщо в об'єкті-акумуляторі acc відсутня своя властивість з ключем tag,
// то створюємо її і записуємо їй значення 0.
// В іншому випадку збільшуємо значення на 1.
const getTagStats = (acc, tag) => {
  if (!acc.hasOwnProperty(tag)) {
    acc[tag] = 0;
  }

  acc[tag] += 1;

  return acc;
};

// Початкове значення акумулятора - це порожній об'єкт {}
const countTags = tags => tags.reduce(getTagStats, {});

const tagCount = countTags(tags);
console.log(tagCount);


//=========================

Метод sort()
Метод  sort() сортирует элементы массива, но в отличие от других методов переборки, он сортирует исходный массив.

Сортирует и изменяет исходный массив.
Возвращает измененный массив, то есть ссылку на отсортированный выходной.
По умолчанию сортирует по росту.
Сортировка производится путем приведения значений к строке и сравнения порядковых номеров в таблице Unicode.
Такой массив чисел будет отсортирован по росту.

const scores = [61, 19, 74, 35, 92, 56];
scores.sort();
console.log(scores); // [19, 35, 56, 61, 74, 92]

Но поскольку по умолчанию значения приводятся к строке, стандартная сортировка чисел работает необычно.Поэтому в следующем упражнении мы рассмотрим как задавать свой порядок сортировки.

const scores = [27, 2, 41, 4, 7, 3, 75];
scores.sort();
console.log(scores); // [2, 27, 3, 4, 41, 7, 75]

Массив строк сортируется по алфавиту.

const students = ["Віка", "Андрій", "Олег", "Юля", "Борис", "Катя"];
students.sort();
console.log(students); // [ 'Андрій', 'Борис', 'Віка', 'Катя', 'Олег', 'Юля' ]


В то же время порядковый номер заглавных меньше, чем у строчных.

const letters = ["b", "B", "a", "A", "c", "C"];
letters.sort();
console.log(letters); // ['A', 'B', 'C', 'a', 'b', 'c']


Из - за сортировки исходного массива нарушается принцип чистоты функций и нельзя удобно создать несколько производных коллекций на основе исходной.Например, создать коллекцию, отсортированную по росту, а другую – по убыванию.Поэтому перед сортировкой производят полную копию исходного массива и сортируют уже ее.

const scores = [61, 19, 74, 35, 92, 56];
const ascendingScores = [...scores].sort();

console.log(scores); // [61, 19, 74, 35, 92, 56]
console.log(ascendingScores); // [19, 35, 56, 61, 74, 92]

Свой порядок сортировки чисел

Для указания своего порядка сортировки метода  sort(compareFunction) следует передать колбек - функцию с двумя параметрами.Это функция сравнения(compare function), порядок сортировки зависит от ее результата.Метод  sort() будет вызывать ее для двух случайных элементов.

массив.sort((a, b) => {
  // Тіло колбек-функції
});

a – первый элемент для сравнения.
b – второй элемент для сравнения.
Если вызов  compareFunction(a, b) возвращает любое отрицательное значение, то есть  a меньше  b, сортировка поставит  a перед  b.Это сортировка по росту.

const scores = [61, 19, 74, 35, 92, 56];
const ascendingScores = [...scores].sort((a, b) => a - b);
console.log(ascendingScores); // [19, 35, 56, 61, 74, 92]

Если вызов  compareFunction(a, b) возвращает любое положительное значение больше нуля, то есть  b больше  a, сортировка поставит  b перед  a.Это сортировка по убыванию.

const scores = [61, 19, 74, 35, 92, 56];
const descendingScores = [...scores].sort((a, b) => b - a);
console.log(descendingScores); // [92, 74, 61, 56, 35, 19]

Если вызов  compareFunction(a, b) вернет 0, сортировка оставит  a и  b неизменными по отношению друг к другу, но отсортирует их по отношению ко всем остальным элементам. Но вообще неважно, что возвращать, если их взаимный порядок не суть важно.



Свой порядок сортировки строк

Для сортировки строк в алфавитном порядке, по возрастанию или убыванию, используется метод строк  localeCompare()

firstString.localeCompare(secondString)

Он вызывается на строке, которую нужно сравнить(firstString) с тем, что был передан ему в качестве аргумента(secondString).

"a".localeCompare("b"); // -1
"b".localeCompare("a"); // 1
"a".localeCompare("a"); // 0
"b".localeCompare("b"); // 0

Возвращает отрицательное значение, если  firstString он должен быть перед  secondString.
Возвращает положительное значение больше нуля, если  firstString должно быть после  secondString.
Если строки одинаковы, то возвращается ноль.
Это удобно использовать для сортировки строк, поскольку метод  sort() ожидает такие же значения от колбек - функции.

const students = ["Віка", "Андрій", "Олег", "Юля", "Борис", "Катя"];

const inAlphabetOrder = [...students].sort((a, b) => a.localeCompare(b));
console.log(inAlphabetOrder); // ['Андрій', 'Борис', 'Віка', 'Катя', 'Олег', 'Юля']

const inReversedOrder = [...students].sort((a, b) => b.localeCompare(a));
console.log(inReversedOrder); // ['Юля', 'Олег', 'Катя', 'Віка', 'Борис', 'Андрій']

Сортировка объектов

При работе с массивом объектов сортировка выполняется по числовому или строковому значению определенного свойства.К примеру, у нас есть группа студентов с баллами за тест.Необходимо отсортировать массив объектов по возрастанию и убыванию количества баллов и по имени студента.

const students = [
  { name: "Манго", score: 83 },
  { name: "Полі", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Ківі", score: 94 },
];

const inAscendingScoreOrder = students.sort(
  (firstStudent, secondStudent) => firstStudent.score - secondStudent.score
);

const inDescendingScoreOrder = students.sort(
  (firstStudent, secondStudent) => secondStudent.score - firstStudent.score
);

const inAlphabeticalOrder = students.sort((firstStudent, secondStudent) =>
  firstStudent.name.localeCompare(secondStudent.name)
);


//=========================================


Цепочки методов
У нас есть массив объектов с именами, баллами и посещаемыми предметами каждого студент

const students = [
  { name: "Манго", score: 83, courses: ["математика", "фізика"] },
  { name: "Полі", score: 59, courses: ["інформатика", "математика"] },
  { name: "Аякс", score: 37, courses: ["фізика", "біологія"] },
  { name: "Ківі", score: 94, courses: ["література", "інформатика"] },
];

Необходимо получить массив их имен, отсортированных по росту баллов за тест. С этой целью мы отсортируем копию массива методом  sort(), после чего методом  map() создадим массив значений свойства  name из отсортированного массива.

const sortedByAscendingScore = [...students].sort((a, b) => a.score - b.score);
const names = sortedByAscendingScore.map(student => student.name);

console.log(names); // ['Аякс', 'Полі', 'Манго', 'Ківі']

Проблема в том, что у нас появляются промежуточные переменные после каждой операции, кроме финальной. Переменная  sortedByAscendingScore – излишняя и необходима только для хранения промежуточного результата.



Избавиться от таких «мертвых» переменных можно с помощью группировки вызовов методов в цепочке.Каждый последующий метод будет выполняться на основе результата предыдущей работы.

const names = [...students]
  .sort((a, b) => a.score - b.score)
  .map(student => student.name);

console.log(names); // ['Аякс', 'Полі', 'Манго', 'Ківі']


Делаем копию исходного массива перед сортировкой.
На копии вызываем метод  sort().
К результату работы метода  sort() применяем метод  map().
Переменной  names присваивается результат работы метода  map().
Получим массив уникальных посещаемых предметов, отсортированный по алфавиту.

const uniqueSortedCourses = students
  .flatMap(student => student.courses)
  .filter((course, index, array) => array.indexOf(course) === index)
  .sort((a, b) => a.localeCompare(b));

console.log(uniqueSortedCourses); // ['біологія', 'інформатика', 'література', 'математика', 'фізика']

На исходном массиве вызываем  flatMap() и производим разглаженный массив всех курсов.
К результату метода  flatMap() применяем метод  filter() для фильтрации уникальных элементов.
В результате метода  filter() вызываем  sort().
Переменной  uniqueSortedCourses присваивается результат работы метода  sort().


Цепочка методов может быть произвольной длины, но обычно не более 2-3 операций. Во-первых, перебирающие методы используются для сравнительно простых операций над коллекцией. Во-вторых, вызов каждого последующего метода - это дополнительная переборка массива, что при большом количестве, может сказаться на производительности.












